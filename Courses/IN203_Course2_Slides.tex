\documentclass[handout]{beamer}
\usetheme{CambridgeUS}
\usepackage{amsmath,amsfonts,graphicx}
\usepackage{beameronera, listings}
%\usepackage{dsfont}
\usepackage{enumitem}
\setlist[description]{style = multiline, labelwidth = 60pt}

\usepackage{tikz} % Required for drawing custom shapes
\usetikzlibrary{shadows, arrows, decorations.pathmorphing, fadings, shapes.arrows, positioning, calc, shapes, fit, matrix}
\usepackage{subcaption}

\usepackage{polyglossia}
%\usepackage[retainorgcmds]{IEEEtrantools}

\definecolor{lightblue}{RGB}{0,200,255} 
\definecolor{paper}{RGB}{239,227,157}
\definecolor{ocre}{RGB}{243,102,25} % Define the orange color used for highlighting throughout the book
\definecolor{BurntOrange}{RGB}{238,154,0}
\definecolor{OliveGreen}{RGB}{188,238,104}
\definecolor{DarkGreen}{RGB}{0,128,0}
\definecolor{BrickRed}{RGB}{238,44,44}
\definecolor{Tan}{RGB}{210,180,140}
\definecolor{Aquamarine}{RGB}{127,255,212}
\definecolor{NavyBlue}{RGB}{0,64,128}

\title[Architectures parallèles\hspace{2em}]{Calcul parallèle distribué}
\author[Xavier JUVIGNY]{Xavier JUVIGNY}
\date{\today}

\institute{ONERA}


\begin{document}

\setbeamertemplate{enumerate item}
{
  \begin{pgfpicture}{-1ex}{-0.65ex}{1ex}{1ex}
    \usebeamercolor[fg]{item projected}
    {\pgftransformscale{1.75}\pgftext{\normalsize\pgfuseshading{bigsphere}}}
    {\pgftransformshift{\pgfpoint{0pt}{0.5pt}}
      \pgftext{\usebeamercolor[fg]{item projected}\usebeamerfont*{item projected}\insertenumlabel}}
  \end{pgfpicture}%
}

\setbeamertemplate{enumerate subitem}
{
  \begin{pgfpicture}{-1ex}{-0.55ex}{1ex}{1ex}
    \usebeamercolor[fg]{subitem projected}
    {\pgftransformscale{1.4}\pgftext{\normalsize\pgfuseshading{bigsphere}}}
    \pgftext{%
      \usebeamercolor[fg]{subitem projected}%
      \usebeamerfont*{subitem projected}%
      \insertsubenumlabel}
  \end{pgfpicture}%
}

\setbeamertemplate{enumerate subsubitem}
{
  \begin{pgfpicture}{-1ex}{-0.55ex}{1ex}{1ex}
    \usebeamercolor[fg]{subsubitem projected}
    {\pgftransformscale{1.4}\pgftext{\normalsize\pgfuseshading{bigsphere}}}
    \pgftext{%
      \usebeamercolor[fg]{subsubitem projected}%
      \usebeamerfont*{subitem projected}%
      \insertsubsubenumlabel}
  \end{pgfpicture}%
}

\lstset{%
  basicstyle=\scriptsize,
  frame=single,
  keywordstyle=\color{blue},
  language=C++,
  commentstyle=\color{red},
  stringstyle=\color{brown},
  keepspaces=true,
  showspaces=false,
  tabsize=2
}
\setbeamertemplate{itemize items}[ball]

\begin{frame}
 \titlepage
\end{frame}

\begin{frame}
\frametitle{Plan du cours}
\tableofcontents
\end{frame}

\section{Architecture des calculateurs à mémoire distribuée}

\begin{frame}[fragile]
\frametitle{Calculateur à mémoire distribuée}

\begin{block}{Définitions}
\begin{itemize}
\item \textbf{N{\oe}ud de calcul} : Une ou plusieurs unités de calculs et une mémoire vive;
\item \textbf{Calculateur à mémoire distribuée} : Calculateur contenant plusieurs n{\oe}uds de calcul
pouvant communiqués entre eux au travers d'un bus spécialisé ou un réseau éthernet.
\end{itemize}
\end{block}

\begin{figure}[h]
\begin{center}
\begin{tikzpicture}
\node[draw,fill=blue!50!white, drop shadow, rounded corners] (Ram1) {Mémoire vive};
\node[below=2ex of Ram1.south] (B1) {};
\node[left=1em of B1.west,draw,fill=red!55] (U1) {UC};
\node[right=1em of B1.east,draw,fill=red!55] (U2) {UC};
\draw[blue] (Ram1) -- (B1.center);
\draw[blue] (B1.center) -- (U1);
\draw[blue] (B1.center) -- (U2);

\node[draw,fill=blue!50!white, drop shadow, rounded corners,left=10em of Ram1.east] (Ram2) {Mémoire vive};
\node[below=2ex of Ram2.south] (B2) {};
\node[left=1em of B2.west,draw,fill=red!55] (U3) {UC};
\node[right=1em of B2.east,draw,fill=red!55] (U4) {UC};
\draw[blue] (Ram2) -- (B2.center);
\draw[blue] (B2.center) -- (U3);
\draw[blue] (B2.center) -- (U4);

\node[draw,fill=blue!50!white, drop shadow, rounded corners,left=10em of Ram2.east] (Ram3) {Mémoire vive};
\node[below=2ex of Ram3.south] (B3) {};
\node[left=1em of B3.west,draw,fill=red!55] (U5) {UC};
\node[right=1em of B3.east,draw,fill=red!55] (U6) {UC};
\draw[blue] (Ram3) -- (B3.center);
\draw[blue] (B3.center) -- (U5);
\draw[blue] (B3.center) -- (U6);

\node[above=2ex of Ram1.north] (R1) {};
\node[above=2ex of Ram2.north] (R2) {};
\node[above=2ex of Ram3.north] (R3) {};
\node[right=1em of R1.east] (R0){};
\node[left=1em of R3.west] (R4) {};
\draw[thick,red] (R0.east) -- (R1.center) -- (R2.center) node[above] {Réseau}-- (R3.center) -- (R4.west);
\draw[thick,red] (Ram1) -- (R1.center);
\draw[thick,red] (Ram2) -- (R2.center);
\draw[thick,red] (Ram3) -- (R3.center);
\end{tikzpicture}
\end{center}
\caption{Architecture calculateur à mémoire distribuée}
\label{fig:archmemdistrib}
\end{figure}
\end{frame}

\begin{frame}[fragile]
\frametitle{Modèle de programmation}

\begin{block}{Modèle de programmation}
\begin{itemize}
\item Exécute simultanément \texttt{nbp} processus;
\item Chaque processus a un numéro unique ( de 0 à \texttt{nbp-1});
\item Les processus échangent des données en envoyant/recevant des messages;
\item \textcolor{orange}{message envoyé} : les données, quantité de données, types de données, destinataire,
identifiant du message ( et groupe de communication\ldots )
\item \textcolor{orange}{message reçu} : buffer réception, quantité de données attendues, type données,
expéditeur, identifiant du message ( groupe de communication\ldots), status échange ( ok, incomplète, \ldots ).
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Coût d'un envoi}

\[
  T_{\mbox{Envoi}} = \mbox{Temps initialisation message} + N.\mbox{Taux de transfert}
\]

$N$ : Quantité de données à envoyer (Mb)

Si le n{\oe}ud expéditeur n'est pas connecté directement au n{\oe}ud destinataire :
passe par des n{\oe}uds transitoires $\Rightarrow$ augmentation du temps d'envoi/réception
\end{frame}

\begin{frame}[fragile]
\frametitle{Topologie d'un réseau}

\textbf{Topologie d'une réseau} : Manière dont sont interconnectés les n{\oe}uds de calcul

\begin{block}{Définitions}
\begin{itemize}
\item \textcolor{orange}{Distance entre deux n{\oe}uds} : Nombre minimal de n{\oe}uds intermédiaire
par lesquels doit passer le message;
\item \textcolor{orange}{Diamètre d'un réseau} : Distance maximale possible entre deux n{\oe}uds
du calculateur parallèle.
\end{itemize}
\end{block}
\end{frame}

\begin{frame}[fragile]
\frametitle{Topologie linéaire}

\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[text width=2.2em,draw,fill=yellow,drop shadow, text centered] (N0) {\small Nœud 0};
%\node[below= 2ex of N0.south] (C0) {};
%\draw[thick,red] (N0) -- (C0.center);
\foreach \x/\p in {1/0,2/1,3/2} {
\node[text width=2.2em, right=2em of N\p.east,draw,fill=yellow,drop shadow, text centered] (N\x) {\small Nœud \x};
\draw[thick,red] (N\p) -- (N\x);
%\node[below= 2ex of N\x.south] (C\x) {};
%\draw[thick,red] (N\x) -- (C\x.center);
}
%\node[left=2em of C0.west] (Cb) {};
%\node[right=2em of C3.east] (Ce) {};
%\draw[thick,red] (Cb) -- (Ce);
\end{tikzpicture}
\end{center}
\label{fig:reslin}
\caption{Réseau Linéaire}
\end{figure}

diamètre $= N-1$.

\end{frame}

\begin{frame}[fragile]
\frametitle{Topologie en anneau}

\begin{figure}
\begin{center}
\begin{tikzpicture}
\node[text width=2.2em,draw,fill=yellow,drop shadow, text centered] (N0) {\small Nœud 0};
%\node[below= 2ex of N0.south] (C0) {};
%\draw[thick,red] (N0) -- (C0.center);
\foreach \x/\p in {1/0,2/1,3/2} {
\node[text width=2.2em, right=2em of N\p.east,draw,fill=yellow,drop shadow, text centered] (N\x) {\small Nœud \x};
\draw[thick,red] (N\p) -- (N\x);
%\node[below= 2ex of N\x.south] (C\x) {};
%\draw[thick,red] (N\x) -- (C\x.center);
}
\node[above=1em of N0.north] (L) {};
\node[above=1em of N3.north] (R) {};
\draw[thick,red] (N0) -- (L.center) -| (R.center) -- (N3);
%\draw[thick,red] (C0.center) -- (C3.center);
\end{tikzpicture}
\end{center}
\label{fig:resanneau}
\caption{Réseau en anneau}
\end{figure}

diamètre $= \frac{N}{2}$ si $N$ pair, $ = \frac{N-1}{2}$ si $N$ impair.
\end{frame}

\begin{frame}[fragile]
\frametitle{Topologie grille}

\begin{figure}[h]
\begin{center}
\begin{tikzpicture}
\node (O0) {};
\foreach \i in {1,2,3,4}{
  \pgfmathtruncatemacro{\im}{\i-1};
  \node[below=1ex of O\im.south] (O\i) {};
  \foreach \j in {1,2,3} {
    \pgfmathtruncatemacro{\ipj}{\i+(\j-1)*4-1};
    \node[text width=1em, fill=yellow, drop shadow] at (\i cm, \j cm) (Nd\i\j)
    {\scriptsize $N_{\ipj}$};
  }
}
\foreach \i in {1,2,3}{
  \pgfmathtruncatemacro{\ip}{\i+1};
  \foreach \j in {1,2} {
    \pgfmathtruncatemacro{\jp}{\j+1};
    \draw[red,thick] (Nd\i\j) -- (Nd\ip\j);
    \draw[red,thick] (Nd\i\j) -- (Nd\i\jp);
  }
}
\foreach \i in {1,2,3}{
  \pgfmathtruncatemacro{\ip}{\i+1};
    \draw[red,thick] (Nd\i3) -- (Nd\ip3);
}
\foreach \j in {1,2} {
    \pgfmathtruncatemacro{\jp}{\j+1};
    \draw[red,thick] (Nd4\j) -- (Nd4\jp);
  }
\end{tikzpicture}
\end{center}
\caption{Réseau sur grille}
\label{fig:gridnet}
\end{figure}

Diamètre $= W+H-2$

\end{frame}

\begin{frame}[fragile]
\frametitle{Réseau hypercube}

\begin{figure}[h]
\centering
\begin{subfigure}[c]{0.46\textwidth}
\centering
\begin{tikzpicture}
\node[text width=1em, fill=yellow, drop shadow]  (N0) {\scriptsize $N_{0}$};
\end{tikzpicture}
\caption{$\mathcal{C}_{0}$ : hypercube dimension 0}\label{fig:HypCub0}
\end{subfigure}
%\qquad
\begin{subfigure}[c]{0.46\textwidth}
\centering
\begin{tikzpicture}
\node[text width=1em, fill=yellow, drop shadow]  (N0) {\scriptsize $N_{0}$};
\node[right=2em of N0.east, text width=1em, fill=yellow, drop shadow] (N1) {\scriptsize $N_{1}$};
\draw[thick,red] (N0) -- (N1);
\end{tikzpicture}
\caption{$\mathcal{C}_{1}$ : hypercube dimension 1}\label{fig:HypCub1}
\end{subfigure}

\begin{subfigure}[c]{0.46\textwidth}
\centering
\begin{tikzpicture}
\node[text width=1em, fill=yellow, drop shadow]  (N0) {\scriptsize $N_{00}$};
\node[right=2em of N0.east, text width=1em, fill=yellow, drop shadow] (N1) {\scriptsize $N_{01}$};
\node[text width=1em, fill=yellow!76!red, drop shadow, above=4ex of N0.north] (N2) {\scriptsize $N_{10}$};
\node[right=2em of N2.east, text width=1em, fill=yellow!76!red, drop shadow] (N3) {\scriptsize $N_{11}$};
\draw[thick,red](N0) -- (N1);
\draw[thick,red](N0) -- (N2);
\draw[thick,red](N2) -- (N3);
\draw[thick,red](N1) -- (N3);
\end{tikzpicture}
\caption{$\mathcal{C}_{2}$ : hypercube dimension 2}\label{fig:HypCub2}
\end{subfigure}
%\qquad
\begin{subfigure}[c]{0.46\textwidth}
\centering
\begin{tikzpicture}
\node[text width=2em, fill=yellow, drop shadow]  (N0) {\scriptsize $N_{000}$};
\node[right=3em of N0.east, text width=2em, fill=yellow, drop shadow] (N1) {\scriptsize $N_{001}$};
\node[text width=2em, fill=yellow!76!red, drop shadow, above=4ex of N0.north] (N2) {\scriptsize $N_{010}$};
\node[right=3em of N2.east, text width=2em, fill=yellow!76!red, drop shadow] (N3) {\scriptsize $N_{011}$};
\node[text width=2em, fill=yellow!50!white, drop shadow, above = 8ex of N0.north east, anchor=west]  (N4) {\scriptsize $N_{100}$};
\node[right=3em of N4.east, text width=2em, fill=yellow!50!white, drop shadow] (N5) {\scriptsize $N_{101}$};
\node[text width=2em, fill=yellow!76!orange, drop shadow, above=4ex of N4.north] (N6) {\scriptsize $N_{110}$};
\node[right=3em of N6.east, text width=2em, fill=yellow!76!orange, drop shadow] (N7) {\scriptsize $N_{111}$};
\draw[thick,red!50!blue](N0) -- (N4);
\draw[thick,red!50!blue](N1) -- (N5);
\draw[thick,red](N0) -- (N1);
\draw[thick,red](N0) -- (N2);
\draw[thick,red](N2) -- (N3);
\draw[thick,red](N1) -- (N3);
\draw[thick,orange](N4) -- (N5);
\draw[thick,orange](N4) -- (N6);
\draw[thick,orange](N6) -- (N7);
\draw[thick,orange](N5) -- (N7);
\draw[thick,red!50!blue](N2) -- (N6);
\draw[thick,red!50!blue](N3) -- (N7);
\end{tikzpicture}
\caption{$\mathcal{C}_{3}$ : hypercube dimension 3}\label{fig:HypCub3}
\end{subfigure}

\caption{Réseau hyper cube de dimensions 0 à 3.}
\end{figure}

Nœuds numérotés en binaire selon numérotation de Gray.
 
Diamètre du réseau $=$ dimension du cube.
\end{frame}

\begin{frame}[fragile]
\frametitle{Réseau hypercube}


\begin{figure}[h]
\centering
\begin{subfigure}[c]{0.46\textwidth}
\centering
\begin{tikzpicture}
\node[text width=2em, fill=yellow, drop shadow]  (N0) {\scriptsize $N_{0000}$};
\node[right=3em of N0.east, text width=2em, fill=yellow, drop shadow] (N1) {\scriptsize $N_{0001}$};
\node[text width=2em, fill=yellow!76!red, drop shadow, above=4ex of N0.north] (N2) {\scriptsize $N_{0010}$};
\node[right=3em of N2.east, text width=2em, fill=yellow!76!red, drop shadow] (N3) {\scriptsize $N_{0011}$};
\node[text width=2em, fill=yellow!50!white, drop shadow, above = 8ex of N0.north east, anchor=west]  (N4) {\scriptsize $N_{0100}$};
\node[right=3em of N4.east, text width=2em, fill=yellow!50!white, drop shadow] (N5) {\scriptsize $N_{0101}$};
\node[text width=2em, fill=yellow!76!orange, drop shadow, above=4ex of N4.north] (N6) {\scriptsize $N_{0110}$};
\node[right=3em of N6.east, text width=2em, fill=yellow!76!orange, drop shadow] (N7) {\scriptsize $N_{0111}$};

\node[text width=2em, fill=cyan, drop shadow, above left = 16ex of N0.north west]  (N8) {\scriptsize $N_{1000}$};
\node[right=3em of N8.east, text width=2em, fill=cyan, drop shadow] (N9) {\scriptsize $N_{1001}$};
\node[text width=2em, fill=cyan!76!green, drop shadow, above=4ex of N8.north] (NA) {\scriptsize $N_{1010}$};
\node[right=3em of NA.east, text width=2em, fill=cyan!76!green, drop shadow] (NB) {\scriptsize $N_{1011}$};
\node[text width=2em, fill=cyan!50!white, drop shadow, above = 8ex of N8.north east, anchor=west]  (NC) {\scriptsize $N_{1100}$};
\node[right=3em of NC.east, text width=2em, fill=cyan!50!white, drop shadow] (ND) {\scriptsize $N_{1101}$};
\node[text width=2em, fill=cyan!76!yellow, drop shadow, above=4ex of NC.north] (NE) {\scriptsize $N_{1110}$};
\node[right=3em of NE.east, text width=2em, fill=cyan!76!yellow, drop shadow] (NF) {\scriptsize $N_{1111}$};
\draw[thick,red!50!blue](N0) -- (N4);
\draw[thick,red!50!blue](N1) -- (N5);
\draw[thick,red](N0) -- (N1);
\draw[thick,red](N0) -- (N2);
\draw[thick,red](N2) -- (N3);
\draw[thick,red](N1) -- (N3);
\draw[thick,orange](N4) -- (N5);
\draw[thick,orange](N4) -- (N6);
\draw[thick,orange](N6) -- (N7);
\draw[thick,orange](N5) -- (N7);
\draw[thick,red!50!blue](N2) -- (N6);
\draw[thick,red!50!blue](N3) -- (N7);

\draw[thick,red!50!blue](N8) -- (NC);
\draw[thick,red!50!blue](N9) -- (ND);
\draw[thick,red](N8) -- (N9);
\draw[thick,red](N8) -- (NA);
\draw[thick,red](NA) -- (NB);
\draw[thick,red](N9) -- (NB);
\draw[thick,orange](NC) -- (ND);
\draw[thick,orange](NC) -- (NE);
\draw[thick,orange](NE) -- (NF);
\draw[thick,orange](ND) -- (NF);
\draw[thick,red!50!blue](NA) -- (NE);
\draw[thick,red!50!blue](NB) -- (NF);

\draw[green] (N0) -- (N8);
\draw[green] (N1) -- (N9);
\draw[green!75] (N2) -- (NA);
\draw[green!75] (N3) -- (NB);
\draw[green!50] (N4) -- (NC);
\draw[green!50] (N5) -- (ND);
\draw[green!25] (N6) -- (NE);
\draw[green!25] (N7) -- (NF);
\end{tikzpicture}
\caption{$\mathcal{C}_{4}$ : hypercube dimension 4}\label{fig:HypCub4}
\end{subfigure}
\caption{Réseau hyper cube de dimension 4.}
\end{figure}

Diamètre du réseau $=$ dimension du cube.

\end{frame}

\section{Programmation sur calculateur parallèle à mémoire distribuée}

\begin{frame}[fragile]
\frametitle{Modèles de programmation}

\begin{itemize}
\item \textbf{SPSD} ({\bf S}imple {\bf P}rogram {\bf S}imple {\bf D}ata ) :
programmation séquentielle classique

\item \textbf{SPMD} ( {\bf S}imple {\bf P}rogram {\bf Multiple} {\bf Data} ) :
Même programme exécuté sur chaque n{\oe}ud, Données différentes

\alert{\`A ne pas confondre avec architecture SIMD !!!!!}

\item \textbf{MPMD} ( {\bf M}ultiple {\bf P}rogram {\bf M}ultiple {\bf D}ata ) :

Chaque n{\oe}ud exécute un programme différent avec des données différentes
\end{itemize}

\begin{block}{Remarque}
Possibilité d'émuler le MPMD avec du SPMD

\begin{lstlisting}[language=C++]
if ( processus == 0 )
  f1 ();
if ( processus == 1 )
  f2 ();
...
\end{lstlisting} 
\end{block}
\end{frame}

\begin{frame}[fragile]{Contexte parallèle}

\begin{itemize}
\item Chaque processus se voit attribué un identifiant unique : un entier
unique par exemple;
\item Chaque processus peut connaître le nombre de processus
exécutés par l'application;
\item Permet d'atribuer les tâches selon l'identifiant et le nombre de processus;
\item Permet d'identifier le destinataire ou l'expéditeur d'un message.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Communication point à point}

\begin{block}{Constitution d'un envoi}
\begin{itemize}
\item Les données à envoyer ( et leurs types et quantité );
\item Le numéro du destinataire;
\item Un identifiant pour le message;
\item \textcolor{gray}{Le groupe de communication utilisé}.
\end{itemize}
\end{block}

\begin{block}{Constitution d'une réception}
\begin{itemize}
\item Un buffer de réception ( et sa taille );
\item Le type des données à recevoir;
\item Le numéro de l'expéditeur;
\item L'identifiant du message;
\item \textcolor{gray}{Le groupe de communication utilisé}.
\item Le status de la réception ( ok, incomplète, raté, \ldots )
\end{itemize}
\end{block}

\end{frame}

\begin{frame}[fragile]{Envoi/Réception bufférisés/non bufférisés}

\begin{figure}[h]
\begin{subfigure}[c]{0.46\textwidth}
\centering
\begin{tikzpicture}
\node[draw,fill=cyan] (E) {Expéditeur};
\node[above = 1mm of E.north, draw, fill=yellow] (T1) {Données à envoyer};
\node[above = 1cm of T1.north, draw, fill=orange] (T2) {Buffer d'envoi};
\node[right = 2cm of T1.east, draw, fill=red] (T3) {Tableau de réception};
\node[draw,fill=green,below = 1mm of T3.south] (R) {Destinataire};
\draw[-latex] (T1.north) -- node[sloped,above] {\scriptsize{Copie}} (T2.south);
\draw[-latex] (T2.south east) -- node[sloped,below]{\scriptsize{envoi}} (T3.south west);
\draw[-latex,blue,dashed] (T3.north west) -- node[sloped,above]{\scriptsize{Reçoit}} (T2.north east);
\end{tikzpicture}
\caption{Schéma d'envoi bufférisé}
\end{subfigure}

\begin{subfigure}[c]{0.46\textwidth}
\centering
\begin{tikzpicture}
\node[draw,fill=cyan] (E) {Expéditeur};
\node[above = 1mm of E.north, draw, fill=yellow] (T1) {Données à envoyer};
\node[right = 2cm of T1.east, draw, fill=red] (T3) {Tableau de réception};
\node[draw,fill=green,below = 1mm of T3.south] (R) {Destinataire};
\draw[-latex] (T1.south east) -- node[sloped,below]{\scriptsize{envoi}} (T3.south west);
\draw[-latex,blue,dashed] (T3.north west) -- node[sloped,above]{\scriptsize{Reçoit}} (T1.north east);
\end{tikzpicture}
\caption{Schéma d'envoi non bufférisé}
\end{subfigure}
\end{figure}

\end{frame}

\begin{frame}[fragile]{Envoi/Réception synchrone}

\begin{figure}
\centering
\begin{tikzpicture}
    \node at (1.5,5) {\scriptsize \texttt{Process 1}};
    \node at (7.5,5) {\scriptsize \texttt{Process 2}};
    \draw[rounded corners=6pt,draw,fill=orange!10] (0,4.8) rectangle (3,0);
    \draw[rounded corners=6pt,draw,fill=orange!10] (6,4.8) rectangle (9,0);
    \draw[->,dotted] (1.5,4.6) -- (1.5,3.25);
    \node[color=red] at (1.5,3.0) {\scriptsize \texttt{envoi();}};
    \draw[->,dotted] (7.5,4.6) -- (7.5,2.25);
    \node[color=red] at (7.5,2) {\scriptsize \texttt{reception();}};
    \draw[|-|,color=blue] (1.5,2.75) to node[below,sloped] (stall)  {\begin{minipage}{1cm}\scriptsize\centering processus suspendu\end{minipage}} (1.5,1.75);
    \draw[->,dotted] (1.5,1.75) -- (1.5,0.25);
    \draw[->,dotted] (7.5,1.75) -- (7.5,0.25);
    \draw[->,color=red!80] (3,3) to node[above] (rq) {\scriptsize Requête d'envoi} (5.9,3);
    \draw[<-,color=blue!50] (3.1,2) to node[above] (ack) {\scriptsize Acceptation} (6,2);
    \draw[->,color=red!80] (3,1.75) to node[below] (msg) {\scriptsize Message} (5.9,1.75);
\end{tikzpicture}    
\caption{Exemple message synchrone quand la réception est exécutée après l'envoi}
\end{figure}

\end{frame}

\begin{frame}[fragile]{Envoi/Réception synchrone}

  \begin{figure}
    \centering
  \begin{tikzpicture}
    \node at (1.5,5) {\scriptsize \texttt{Process 1}};
    \node at (7.5,5) {\scriptsize \texttt{Process 2}};
    \draw[rounded corners=6pt,draw,fill=orange!10] (0,4.8) rectangle (3,0);
    \draw[rounded corners=6pt,draw,fill=orange!10] (6,4.8) rectangle (9,0);
    \draw[->,dotted] (1.5,4.6) -- (1.5,2.25);
    \node[color=red] at (1.5,2.0) {\scriptsize \texttt{envoi();}};
    \draw[->,dotted] (7.5,4.6) -- (7.5,3.75);
    \node[color=red] at (7.5,3.5) {\scriptsize \texttt{réception();}};
    \draw[|-|,color=blue] (7.5,3.25) to node[below,sloped] (stall)  {\begin{minipage}{1cm}\scriptsize\centering Processus suspendu\end{minipage}} (7.5,1.25);
    \draw[->,dotted] (1.5,1.25) -- (1.5,0.25);
    \draw[->,dotted] (7.5,1.25) -- (7.5,0.25);
    \draw[->,color=red!80] (3,2) to node[above] (rq) {\scriptsize Requête d'envoi} (5.9,2);
    \draw[<-,color=blue!50] (3.1,1.5) to node[above] (ack) {\scriptsize Acceptation} (6,1.5);
    \draw[->,color=red!80] (3,1.25) to node[below] (msg) {\scriptsize Message} (5.9,1.25);
  \end{tikzpicture}
  \caption{Exemple message synchrone quand la réception est exécutée avant l'envoi}
  \end{figure}
  
\end{frame}

\begin{frame}[fragile]{Interblocage (deadlock)}

\begin{block}{Cas d'interblocage}
\begin{itemize}
\item tous les processus envoient message bloquant à un autre processus
avant d'effectuer une réception;
\item Ou  cas symétrique où tous les processus attendent un message en réception
avant d'effectuer un envoi.
\end{itemize}
\end{block}

\begin{example}
\begin{lstlisting}
if (rank == 0)
{
    Recoit_synchrone( recvdata, count, tag, 1 );
    Envoi_synchrone ( senddata, count, tag, 1 );
}
else
{
    Recoit_synchrone( recvdata, count, tag, 0 );
    Envoi_synchrone ( senddata, count, tag, 0 );
}
\end{lstlisting}
\end{example}

\end{frame}

\begin{frame}[fragile]{Première solution pour enlever interblocage}

\begin{lstlisting}
if (rank == 0)
{
    Recoit_synchrone( recvdata, count, tag, 1 );
    Envoi_synchrone ( senddata, count, tag, 1 );
}
else
{
    Envoi_synchrone ( senddata, count, tag, 0 );
    Recoit_synchrone( recvdata, count, tag, 0 );
}
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Envoi/Réception asynchrone}
\begin{figure}
\centering
\begin{tikzpicture}
    \node at (1.5,5) {\scriptsize \texttt{Process 1}};
    \node at (7.5,5) {\scriptsize \texttt{Process 2}};
    \draw[rounded corners=6pt,draw,fill=orange!10] (0,4.8) rectangle (3,0);
    \draw[rounded corners=6pt,draw,fill=orange!10] (6,4.8) rectangle (9,0);
    \draw[->,dotted] (1.5,4.6) -- (1.5,3.25);
    \node[color=red] at (1.5,3.0) {\scriptsize \texttt{envoi();}};
    \draw[->,dotted] (7.5,4.6) -- (7.5,2.25);
    \node[color=red] at (7.5,2) {\scriptsize \texttt{reception();}};
    %\draw[|-|,color=blue] (1.5,2.75) to node[below,sloped] (stall)  {\begin{minipage}{1cm}\scriptsize\centering processus suspendu\end{minipage}} (1.5,1.75);
    \draw[->,dotted] (1.5,2.75) -- node[sloped,below] {\scriptsize \textcolor{blue}{Calculs\ldots}} (1.5,0.25);
    \draw[->,dotted] (7.5,1.75) -- (7.5,0.25);
    \draw[->,color=red!80] (3,3) to node[above] (rq) {\scriptsize Requête d'envoi} (5.9,3);
    \draw[<-,color=blue!50] (3.1,2) to node[above] (ack) {\scriptsize Acceptation} (6,2);
    \draw[->,color=red!80] (3,1.75) to node[below] (msg) {\scriptsize Message} (5.9,1.75);
\end{tikzpicture}    
\end{figure}

\end{frame}

\begin{frame}[fragile]{Envoi/Réception asynchrone}

  \begin{figure}
    \centering
  \begin{tikzpicture}
    \node at (1.5,5) {\scriptsize \texttt{Process 1}};
    \node at (7.5,5) {\scriptsize \texttt{Process 2}};
    \draw[rounded corners=6pt,draw,fill=orange!10] (0,4.8) rectangle (3,0);
    \draw[rounded corners=6pt,draw,fill=orange!10] (6,4.8) rectangle (9,0);
    \draw[->,dotted] (1.5,4.6) -- (1.5,2.25);
    \node[color=red] at (1.5,2.0) {\scriptsize \texttt{envoi();}};
    \draw[->,dotted] (7.5,4.6) -- (7.5,3.75);
    \node[color=red] at (7.5,3.5) {\scriptsize \texttt{réception();}};
    %\draw[|-|,color=blue] (7.5,3.25) to node[below,sloped] (stall)  {\begin{minipage}{1cm}\scriptsize\centering Processus suspendu\end{minipage}} (7.5,1.25);
    \draw[->,dotted] (1.5,1.25) -- (1.5,0.25);
    \draw[->,dotted] (7.5,3.25) -- node[below,sloped]{\scriptsize\textcolor{blue}{Calculs\ldots}}(7.5,0.25);
    \draw[->,color=red!80] (3,2) to node[above] (rq) {\scriptsize Requête d'envoi} (5.9,2);
    \draw[<-,color=blue!50] (3.1,1.5) to node[above] (ack) {\scriptsize Acceptation} (6,1.5);
    \draw[->,color=red!80] (3,1.25) to node[below] (msg) {\scriptsize Message} (5.9,1.25);
  \end{tikzpicture}
  \end{figure}
  
  \begin{block}{Synchronisation reportée}
\begin{itemize}
\item Tester si l'envoi ou la réception a bien été effectuée;
\item Attendre plus tard que l'envoi ( ou la réception ) soit effectuée;
\end{itemize}
 \end{block}

\end{frame}

\begin{frame}[fragile]{Deuxième solution pour enlever l'interblocage}

\begin{lstlisting}
if (rank == 0)
{
    Recoit_asynchrone( recvdata, count, tag, 1, status );
    Envoie_synchrone ( senddata, count, tag, 1 );
    Attend_fin_reception( status );
}
else
{
    Recoit_asynchrone( recvdata, count, tag, 0, status );
    Envoie_synchrone ( senddata, count, tag, 0 );
    Attend_fin_reception( status );
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Exercice sur l'interblocage}

\begin{block}{Exercice}
Expliquez pourquoi le code MPI ci dessous n'est pas sûr et peut par moment
conduire à un interblocage.

\begin{lstlisting}
MPI_Comm_rank(comm, &myRank ) ;
if (myRank == 0 ) {
    MPI_Ssend( sendbuf1, count, MPI_INT, 2, tag, comm);
    MPI_Recv( recvbuf1, count, MPI_INT, 2, tag, comm, &status);
} else if ( myRank == 1 ) {
    MPI_Ssend( sendbuf2, count, MPI_INT, 2, tag, comm);
  else if ( myRank == 2 ) {
    MPI_Recv( recvbuf1, count, MPI_INT, MPI_ANY_SOURCE, tag, comm, 
              &status );
    MPI_Ssend( sendbuf2, count, MPI_INT, 0, tag, comm);
    MPI_Recv( recvbuf2, count, MPI_INT, MPI_ANY_SOURCE, tag, comm, 
              &status );
}
\end{lstlisting}
\end{block}

\end{frame}

\section{Communications collectives}

\begin{frame}[fragile]{Les différentes sortes de communications collectives}

{\scriptsize
\begin{itemize}
\item Effectuer une barrière de synchronisation;
\item Mouvement collectif de données
  \begin{itemize}
  \item Diffusion de données d'un processus sur tous les autres processus;
  \item Rassembler sur un ou tous les processus des données réparties sur
  chaque processus;
  \item Distribuer et répartir des données d'un processus sur tous les autres 
  processus;
  \item \'Echanger des données de tous vers tous.
  \end{itemize}
\item Des calculs globaux :
  \begin{itemize}
  \item Effectuer des réductions, c'est à dire faire une opérations sur les données réparties
  sur les processus ( somme, max, multiplication, etc. );
  \item Effectuer un scan, opération cumulative, sur les données réparties
  sur les processus.
  \end{itemize}
\end{itemize}
}

\begin{alertblock}{Optimalité}
Permet d'être optimal sur toute topologie de réseau
\end{alertblock}
\end{frame}

\begin{frame}[fragile]{Synchronisation}

Créee un point de rendez-vous pour tous les processus.

Utile pour faire des mesures de temps entre autre.

\begin{lstlisting}
std::chrono::time_point<std::chrono::system_clock> start, end;
// Tous les processus s'attendent à la ligne suivante
// afin de démarrer en même temps la partie du code
// dont on veut mesurer les performances en parallèle
MPI_Barrier(MPI_COMM_WORLD);
start = std::chrono::system_clock::now();
// La partie du code dont on veut mesurer les performances
...
end = std::chrono::system_clock::now();
...
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Diffusion (Broadcast)}

\begin{figure}[h]
\begin{tikzpicture}
    \node at (1,0) {\scriptsize \texttt{Process 0}};
    \node at (5,0) {\scriptsize \texttt{Process 1}};
    \node at (9,0) {\scriptsize \texttt{Process n-1}};
    \node at (7,0) {\scriptsize \texttt{\ldots}};
    \draw[rounded corners=4pt,draw,fill=orange!10] (0,0.5) rectangle (2,4.25);
    \draw[rounded corners=4pt,draw,fill=orange!10] (4,0.5) rectangle (6,4.25);
    \draw[rounded corners=4pt,draw,fill=orange!10] (8,0.5) rectangle (10,4.25);
    \draw[fill=blue!10,draw] (0.5,3.5) rectangle (1.5,3.75);
    \node[color=blue!70] at (1,4) {\scriptsize data};
    \draw[fill=blue!10,draw] (4.5,3.5) rectangle (5.5,3.75);
    \node[color=blue!70] at (5,4) {\scriptsize data};
    \draw[fill=blue!10,draw] (8.5,3.5) rectangle (9.5,3.75);
    \node[color=blue!70] at (9,4) {\scriptsize data};
    \draw[fill=red!10,draw] (0.5,2.5) rectangle (1.5,2.75);
    \node[color=red!70] at (0.5,3) {\scriptsize Buffer};
    \draw[dotted] (1,3.5) -- (1,2.75);
    \draw[dotted] (1,2.5) -- (1,1.75);
    \node at (1,1.5) {\scriptsize \texttt{bcast();}};
    \draw[dotted] (5,3.5) -- (5,1.75);
    \node at (5,1.5) {\scriptsize \texttt{bcast();}};
    \draw[dotted] (9,3.5) -- (9,1.75);
    \node at (9,1.5) {\scriptsize \texttt{bcast();}};
    \draw[-stealth',thick] (1.5,2.625) .. controls (2,2.75) and (2,3.625) .. (1.5,3.625);
    \draw[-stealth',thick] (1.5,2.625) .. controls (2,2.625) and (5,2.5) .. (5,3.5);
    \draw[-stealth',thick] (1.5,2.625) .. controls (2,2.5) and (9,2.5) .. (9,3.5);
    \draw[dotted] (1,1.25) -- (1,0.75);
    \draw[dotted] (5,1.25) -- (5,0.75);
    \draw[dotted] (9,1.25) -- (9,0.75);
\end{tikzpicture}
\caption{Principe de la diffusion}
\end{figure}

\end{frame}

\begin{frame}[fragile]{Répartition (Scatter)}

\begin{figure}
  \centering
  \begin{tikzpicture}
    \node at (1,0) {\scriptsize \texttt{Process 0}};
    \node at (5,0) {\scriptsize \texttt{Process 1}};
    \node at (9,0) {\scriptsize \texttt{Process n-1}};
    \node at (7,0) {\scriptsize \texttt{\ldots}};
    \draw[rounded corners=4pt,draw,fill=orange!10] (0,0.5) rectangle (2,4.25);
    \draw[rounded corners=4pt,draw,fill=orange!10] (4,0.5) rectangle (6,4.25);
    \draw[rounded corners=4pt,draw,fill=orange!10] (8,0.5) rectangle (10,4.25);
    \draw[fill=blue!10,draw] (0.75,3.5) rectangle (1.25,3.75);
    \node[color=blue!70] at (1,4) {\scriptsize data};
    \draw[fill=blue!10,draw] (4.75,3.5) rectangle (5.25,3.75);
    \node[color=blue!70] at (5,4) {\scriptsize data};
    \draw[fill=blue!10,draw] (8.75,3.5) rectangle (9.25,3.75);
    \node[color=blue!70] at (9,4) {\scriptsize data};
    \draw[fill=red!10,draw, step=0.25] (0.5,2.5) rectangle (1.5,2.75);
    \draw[draw, step=0.25] (0.49,2.49) grid (1.5,2.75);
    \draw[dotted] (1.1,2.625) -- (1.24,2.625);
    \node[color=red!70] at (0.5,2.25) {\scriptsize Buffer};
    \draw[dotted] (1,3.5) -- (1,2.75);
    \draw[dotted] (1,2.5) -- (1,1.75);
    \node at (1,1.5) {\scriptsize \texttt{scatter();}};
    \draw[dotted] (5,3.5) -- (5,1.75);
    \node at (5,1.5) {\scriptsize \texttt{scatter();}};
    \draw[dotted] (9,3.5) -- (9,1.75);
    \node at (9,1.5) {\scriptsize \texttt{scatter();}};
    \draw[-stealth',thick] (0.6,2.75) .. controls (0.6,2.95) and (0.75,3.25) .. (1,3.5);
    \draw[-stealth',thick] (0.9,2.75) .. controls (1.25,3.25) and (4.75,3.25) .. (5,3.5);
    \draw[-stealth',thick] (1.5,2.625) .. controls (1.75,2.625) and (8.75,3.25) .. (9,3.5);
    \draw[dotted] (1,1.25) -- (1,0.75);
    \draw[dotted] (5,1.25) -- (5,0.75);
    \draw[dotted] (9,1.25) -- (9,0.75);
  \end{tikzpicture}
  \caption{Schéma du fonctionnement d'une répartition collective}
\end{figure}

\end{frame}

\begin{frame}[fragile]{Rassemblement (Gather)}

\begin{figure}
  \centering
  \begin{tikzpicture}
    % \draw[step=1mm,color=black!10] (0,0) grid (3cm,3cm);
    % \draw[step=1cm,color=black!50] (0,0) grid (3cm,3cm);
    \node at (1,0) {\scriptsize \texttt{Process 0}};
    \node at (5,0) {\scriptsize \texttt{Process 1}};
    \node at (9,0) {\scriptsize \texttt{Process n-1}};
    \node at (7,0) {\scriptsize \texttt{\ldots}};
    \draw[rounded corners=4pt,draw,fill=orange!10] (0,0.5) rectangle (2,4.25);
    \draw[rounded corners=4pt,draw,fill=orange!10] (4,0.5) rectangle (6,4.25);
    \draw[rounded corners=4pt,draw,fill=orange!10] (8,0.5) rectangle (10,4.25);
    \draw[fill=blue!10,draw] (0.75,3.5) rectangle (1.25,3.75);
    \node[color=blue!70] at (1,4) {\scriptsize data};
    \draw[fill=blue!10,draw] (4.75,3.5) rectangle (5.25,3.75);
    \node[color=blue!70] at (5,4) {\scriptsize data};
    \draw[fill=blue!10,draw] (8.75,3.5) rectangle (9.25,3.75);
    \node[color=blue!70] at (9,4) {\scriptsize data};
    \draw[fill=red!10,draw, step=0.25] (0.5,2.5) rectangle (1.5,2.75);
    \draw[draw, step=0.25] (0.49,2.49) grid (1.5,2.75);
    \draw[dotted] (1.1,2.625) -- (1.24,2.625);
    \node[color=red!70] at (0.5,2.25) {\scriptsize Buffer};
    \draw[dotted] (1,3.5) -- (1,2.75);
    \draw[dotted] (1,2.5) -- (1,1.75);
    \node at (1,1.5) {\scriptsize \texttt{gather();}};
    \draw[dotted] (5,3.5) -- (5,1.75);
    \node at (5,1.5) {\scriptsize \texttt{gather();}};
    \draw[dotted] (9,3.5) -- (9,1.75);
    \node at (9,1.5) {\scriptsize \texttt{gather();}};
    \draw[-stealth',thick] (1,3.5) .. controls (0.75,3.25) and (0.6,2.95) .. (0.6,2.75);
    \draw[-stealth',thick] (5,3.5) .. controls (4.75,3.25) and (1.25,3.25) .. (0.9,2.75);
    \draw[-stealth',thick] (9,3.5) .. controls (8.75,3.25) and (1.75,2.625) .. (1.5,2.625);
    \draw[dotted] (1,1.25) -- (1,0.75);
    \draw[dotted] (5,1.25) -- (5,0.75);
    \draw[dotted] (9,1.25) -- (9,0.75);
  \end{tikzpicture}    
  \caption{Schéma opératoire du rassemblement collectif}
\end{figure}

\end{frame}

\begin{frame}[fragile]{Réduction (reduce)}

\begin{figure}
  \centering
  \begin{tikzpicture}
    % \draw[step=1mm,color=black!10] (0,0) grid (3cm,3cm);
    % \draw[step=1cm,color=black!50] (0,0) grid (3cm,3cm);
    \node at (1,0) {\scriptsize \texttt{Process 0}};
    \node at (5,0) {\scriptsize \texttt{Process 1}};
    \node at (9,0) {\scriptsize \texttt{Process n-1}};
    \node at (7,0) {\scriptsize \texttt{\ldots}};
    \draw[rounded corners=4pt,draw,fill=orange!10] (0,0.5) rectangle (2,4.25);
    \draw[rounded corners=4pt,draw,fill=orange!10] (4,0.5) rectangle (6,4.25);
    \draw[rounded corners=4pt,draw,fill=orange!10] (8,0.5) rectangle (10,4.25);
    \draw[fill=blue!10,draw] (0.75,3.5) rectangle (1.25,3.75);
    \node[color=blue!70] at (1,4) {\scriptsize data};
    \draw[fill=blue!10,draw] (4.75,3.5) rectangle (5.25,3.75);
    \node[color=blue!70] at (5,4) {\scriptsize data};
    \draw[fill=blue!10,draw] (8.75,3.5) rectangle (9.25,3.75);
    \node[color=blue!70] at (9,4) {\scriptsize data};
    \draw[fill=red!10,draw, step=0.25] (0.5,2.5) rectangle (1.5,2.75);
    \node[color=red!70] at (0.5,2.25) {\scriptsize Buffer};
    \draw[dotted] (1,3.5) -- (1,2.75);
    \draw[dotted] (1,2.5) -- (1,1.75);
    \node at (1,1.5) {\scriptsize \texttt{reduce();}};
    \draw[dotted] (5,3.5) -- (5,1.75);
    \node at (5,1.5) {\scriptsize \texttt{reduce();}};
    \draw[dotted] (9,3.5) -- (9,1.75);
    \node at (9,1.5) {\scriptsize \texttt{reduce();}};
    \node[shape=circle,fill=green!20,draw] (plus) at (3,3) {\Large +};
    \draw[-stealth',thick] (1,3.5) to (plus);
    \draw[-stealth',thick] (5,3.5) to (plus);
    \draw[-stealth',thick] (9,3.5) to (plus);
    \draw[-stealth',thick] (plus) to (1.5,2.625);
    \draw[dotted] (1,1.25) -- (1,0.75);
    \draw[dotted] (5,1.25) -- (5,0.75);
    \draw[dotted] (9,1.25) -- (9,0.75);
  \end{tikzpicture}    
\end{figure}

\end{frame}

\begin{frame}[fragile]{Scan}

\begin{figure}
  \centering
  \begin{tikzpicture}
    % \draw[step=1mm,color=black!10] (0,0) grid (3cm,3cm);
    % \draw[step=1cm,color=black!50] (0,0) grid (3cm,3cm);
    \node at (1,0) {\scriptsize \texttt{Process 0}};
    \node at (5,0) {\scriptsize \texttt{Process 1}};
    \node at (9,0) {\scriptsize \texttt{Process 2}};
    %\node at (7,0) {\scriptsize \texttt{\ldots}};
    \draw[rounded corners=4pt,draw,fill=orange!10] (0,0.5) rectangle (2,4.25);
    \draw[rounded corners=4pt,draw,fill=orange!10] (4,0.5) rectangle (6,4.25);
    \draw[rounded corners=4pt,draw,fill=orange!10] (8,0.5) rectangle (10,4.25);
    %\draw[fill=blue!10,draw] (0.75,3.5) rectangle (1.25,3.75);
    \node[color=blue!70,rectangle,fill=blue!10,draw] at (1,3.5) (dat0) {\scriptsize data};
    \node[color=blue!70,rectangle,fill=blue!10,draw] at (5,3.5) (dat1) {\scriptsize data};
    %\draw[fill=blue!10,draw] (8.75,3.5) rectangle (9.25,3.75);
    \node[color=blue!70,rectangle,fill=blue!10,draw] at (9,3.5) (dat2) {\scriptsize data};
    \node[color=red!70,rectangle, fill=red!10,draw] at (5,2.25) (buf1) {\scriptsize Buffer};
    \node[color=red!70,rectangle, fill=red!10,draw] at (9,2.25) (buf2) {\scriptsize Buffer};
    \draw[dotted] (1,3.5) -- (1,2.75);
    \draw[dotted] (1,2.5) -- (1,1.75);
    \node at (1,1.5) {\scriptsize \texttt{scan();}};
    \draw[dotted] (5,3.5) -- (5,1.75);
    \node at (5,1.5) {\scriptsize \texttt{scan();}};
    \draw[dotted] (9,3.5) -- (9,1.75);
    \node at (9,1.5) {\scriptsize \texttt{scan();}};
    \node[shape=circle,fill=green!20,draw] (plus) at (3,3) {\Large +};
    \node[shape=circle,fill=green!20,draw] (plus2) at (7,3) {\Large +};
    \draw[-stealth',thick] (dat0.south) to (plus);
    \draw[-stealth',thick] (dat1.south) to (plus);
    \draw[-stealth',thick] (dat2.west) to (plus2);
    \draw[-stealth',thick] (buf1.east) to (plus2);
    \draw[-stealth',thick] (plus) to (buf1.west);
    \draw[-stealth',thick] (plus2) to (buf2.west);
    \draw[dotted] (1,1.25) -- (1,0.75);
    \draw[dotted] (5,1.25) -- (5,0.75);
    \draw[dotted] (9,1.25) -- (9,0.75);
  \end{tikzpicture}    
\end{figure}
\end{frame}

\section{Développement d'un programme parallèle}

\begin{frame}[fragile]{Déboguer un programme parallèle}

\begin{itemize}
 \item Si possible, d'abord exécuter le programme sur un seul processus, et le déboguer comme
 un programme séquentiel classique;
 \item Exécuter le programme sur de deux à quatre processus sur un même n{\oe}ud ou sur son ordinateur
 personnel. Vérifier que les messages sont bien envoyés au bon processus et qu'un processus reçoit bien
 le bon message. Il arrive souvent qu'il y ait une erreur sur l'identité du message ou bien des messages
 envoyés aux mauvais processus;
 \item Exécuter maintenant le programme à l'aide de deux à quatre processus sur différents
 n{\oe}uds de calcul. Cela vous aidera à mesurer l'impact des délais dûs au réseau et à la
 synchronisation et ainsi mesurer le temps pris pour cela dans votre programme.
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Algorithme parallèle à coût optimal}

\begin{block}{Définition}
Algorithme parallèle vérifiant  que :

\begin{center}
 (Complexité en temps parallèle) $\times$ (nombre de processus) = (complexité en temps séquentiel).
\end{center}

\end{block}

\begin{example}
Soit problème $P$ avec complexité séquentielle en $O(n.\log(n))$.

\textcolor{blue}{Algorithme optimal}
Algorithme parallèle résolvant $P$ avec $n$ processus et coût de $O(\log(n))$ par processus.

\textcolor{red}{Algorithme non optimal}
Algorithme parallèle résolvant $P$ avec $n^{2}$ processus et coût en  $O(1)$ sur chaque processus.
\end{example}
\end{frame}

\section{Mesures de performances}

\begin{frame}[fragile]{Accélération (speedup)}

\begin{block}{Définition}
Soit
\begin{itemize}
\item $t_{s}$ : temps d'exécution séquentiel
\item $t_{p}(n)$ : Temps d'exécution sur $n$ n{\oe}uds de calcul;
\end{itemize}

L'accélération est alors défini par :

\begin{equation}
 S(n) = \frac{t_{s}}{t_{p}(n)}
\end{equation}
\end{block}

\begin{alertblock}{Remarque}
Algorithme utilisé en séquentiel est souvent différent de celui utilisé
en parallèle. Notion d'accélération est un notion très délicate : 
\begin{itemize}
 \item L'algorithme utilisé en séquentiel est-il optimal ? 
 \item Le code séquentiel est-il bien optimisé, et exploite-t'il bien les mémoires caches ?
\end{itemize}
\end{alertblock}

\end{frame}

\begin{frame}[fragile]{Loi d'Amdahl}

\begin{equation}
 S(n) = \frac{t_{s}}{f.t_{s}+\frac{(1-f)t_{s}}{n}} = \frac{n}{1+(n-1)f}
\end{equation}

\begin{itemize}
\item[$t_{s}$] Temps passé en séquentiel
\item[$f$] Fraction ( en temps ) du code non parallélisable. 
\end{itemize}

Permet de dimensionner le nombre de processus pour une application donnée.

\begin{alertblock}{Limitation}
Cette loi est appliquée pour une application donnée, c'est à dire pour une taille
de problème fixée.
\end{alertblock}
\end{frame}

\begin{frame}[fragile]{Loi de Gustafson}

\begin{block}{Définition}

Estimation de l'accélération en fonction du volume de donnée :
\begin{equation}
 S_{s}(n) = \frac{s+n.p}{s+p} = s + n.p = n + (1-n)s
\end{equation}

\begin{itemize}
\item $s$ : proportion en temps du code exécuté en séquentiel;
\item $p$ : proportion en temps du code exécuté en parallèle;
\item $p+s=1, 0\leq p,s \leq 1$
\end{itemize}

\end{block}

\end{frame}

\begin{frame}[fragile]{Diagramme espace--temps}

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[scale=0.9]
\draw (1,3) rectangle (6,3.25) (2,2) rectangle (4,2.25) (2,1) rectangle (3,1.25) (2,0) rectangle (5,0.25);
\draw[fill=red,draw] (4,2) rectangle (4.8,2.25) (3,1) rectangle (4.2,1.25) (5,0) rectangle (5.3,0.25);
\draw (1,-0.5) -- (1,3.25) (2,0) -- (2,3.25);
\draw[->,color=blue] (4.8,2.25) -- (4.9,3);
\draw[->,color=blue] (4.2,1.25) -- (4.3,3);
\draw[->,color=blue] (5.3,0.25) to node[midway, sloped] (x) 
        {\begin{minipage}{22mm}\scriptsize\color{black} Pente = temps d'envoi message\end{minipage}} (5.4,3);
\draw[->] (1,-0.5) --  (6.25,-0.5);
\node at (3,-0.25) {\scriptsize Calcul};
\node at (5.15,-0.25) {\scriptsize Communication};
\node at (0,3) {\scriptsize processus 1};
\node at (0,2) {\scriptsize processus 2};
\node at (0,1) {\scriptsize processus 3};
\node at (0,0) {\scriptsize processus 4};
\node at (6.,-0.75) {\scriptsize Temps};
\draw[fill=red,draw] (-0.55,-1) rectangle (0.7,-0.75);
\node at (1.9,-1) {\begin{minipage}{20mm}\scriptsize  Attente d'envoi de message\end{minipage}};
\draw[->,color=blue] (3.5,-1.25) -- (3.6,-0.75);
\node at (4.25,-1.) {\scriptsize Message};
\end{tikzpicture}
\caption{Exemple de diagramme espace--temps}
\label{fig::spacetimediag}
\end{figure}

Visualise les temps d'inaction des processus ( synchronisation, attente de messages, etc. )

\end{frame}

\begin{frame}[fragile]{Efficacité}

\begin{block}{Définition}
Fraction du temps durant lequel les n{\oe}uds sont utilisés pour traiter les données

\begin{equation}
 E(n) = 100.\times \frac{t_{s}}{t_{p}(n)\times n} = 100\times\frac{S(n)}{n}
\end{equation}
\end{block}

\end{frame}

\begin{frame}[fragile]{Coût d'un calcul parallèle}

\begin{block}{Définition}
Estimation du coût en énergie mais également pour la facturation des heures
de calcul d'un programme parallèle en train de s'exécuter

\begin{equation}
 C(n) = n \times t_{p}(n) = \frac{n.t_{s}}{S(n)} = \frac{t_{s}}{E(n)}
\end{equation}
\end{block}

\begin{block}{programme séquentiel}

\begin{equation}
 C(1) = 1 \times t_{s} = t_{s}
\end{equation}

\end{block}

Coùt optimal si $E(n)$ est constant.
\end{frame}

\begin{frame}[fragile]{Scalabilité}

\begin{block}{Définition}
Capacité du programme à avoir un bon speedup avec la montée en nombre de processus et
une taille croissante de donnée à traiter
\end{block}

\begin{block}{\'Evaluation de la scalabilité}
En fait, on fera deux courbes de speed-up :
\begin{itemize}
\item L'une avec une taille fixe de donnée;
\item L'autre avec une taille croissante de donnée en fonction du nombre
de processus.
\end{itemize}
\end{block}
\end{frame}

\section{Optimisation d'un code parallèle}
\begin{frame}[fragile]{\'Equilibrage des charges}

\begin{block}{Définition}
Tous les processus mettent le même temps de traitement de leurs
données.
\end{block}

\begin{example}
Un programme s'exécute en $t$ secondes, mais la moitié des processus
mettent $\frac{t}{2}$ secondes pour finir leur traitement.

L'efficacité maximal d'un tel programme sera de 75\%
\end{example}
\end{frame}

\begin{frame}[fragile]{\'Equilibrage dynamique des charges}

\begin{itemize}
\item Algorithme itératif : impossible de prédire le temps d'exécution de chaque processus ( pour Mandelbrot
par exemple );
\item Répartition des charges impossible à l'avance. Doit être décidé durant l'exécution du programme.
\item Stratégie maître--esclave :
\begin{itemize}
\item Un processus maître créee un ensemble de tâches pour résoudre le problème
\item Il distribue une tâche sur chaque processus esclave.
\item D\`es qu'un processus esclave a fini sa tâche, il renvoie la solution;
\item Le processus maître lui renvoie immédiatement la prochaine tâche non executée;
\item Le processus maître envoie un signal de terminaison dès que toutes les tâches
ont été exécutées.
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Squelette algorithme maître--esclave}

Processus maître : processus 0

\begin{lstlisting}
MPI_Init();
...
if ( rank == 0 )// rank == 0 => master
{
  int count_task = 0;
  for ( int i = 1; i < nbp; ++i ) {
     send(&count_task, 1, MPI_INT, i, ... );     
     count_task += 1;
  }
  while (count_task < nb_tasks) {
    // status contiendra le numéro du proc ayant envoyé
    // le résultat... : status.MPI_SOURCE en MPI
    recv(result, ..., MPI_ANY_SOURCE, ..., &status );
    send(&count_task, 1, MPI_INT, status.MPI_SOURCE, ... );     
    count_task += 1;    
  }
  // On envoie un signal de terminaison à tous les processus
  count_task = -1;
  for ( int i = 1; i<nbp; ++i ) send(&count_task, 1, MPI_INT, i, ... );
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Squelette algorithme maître--esclave}

\begin{lstlisting}
if (rank > 0)
{// Cas où je suis un travailleur
  int num_task = 0;
  // Tant que je ne reçois pas le n° de terminaison
  while (num_task != -1)
  {
    recv(&num_task, 1, MPI_INT, 0, ... );
    if (num_task >= 0) {
      // Exécute la tâche correspondant au numéro
      execute_task(num_task, ...);
      // Renvoie le résultat avec son numéro 
      send(result, ..., 0, ... );
    }
  }
}
MPI_Finalize();
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Granularité parallèle}


\begin{block}{Définition}
Rapport du nombre d'opérations effectuées sur le nombre de données
échangés
\end{block}

Quand ce nombre devient trop petit, le programme passe plus de temps à
communiquer qu'à calculer $\Rightarrow$ mauvaise efficacité obtenue.

Antagoniste avec la notion d'équilibre des charges
\end{frame}

\begin{frame}[fragile]{Recouvrement des échanges de message par les calculs}

En utilisant les messages asynchrones, on peut recouvrir une partie des
échanges de message par des calculs.

Il faudra cependant à faire une synchronisation a postiori plus loin dans
le code.

\end{frame}
\end{document}
